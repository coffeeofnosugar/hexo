---
title: 【Unity】多线程
date: 2023-09-18 14:03:06
tags:
  - Unity
  - C#
---

### 最简单的使用方法

```C#
using System.Threading;

void start()
{
    Thread t1 = new Thread(A);
    Thread t2 = new Thread(B);
    t1.start();
    t2.start();
}

void A()
{
    Debug.Log("我是A函数1");
    Debug.Log("我是A函数2");
}

void B()
{
    Debug.Log("我是B函数1");
    Debug.Log("我是B函数2");
}
```

此时的输出结果是不可控的，可能先执行A，也可能先执行B，这个是操作系统根据CPU自动计算出来的。
而且A和B是会嵌套交叉执行的

如何让程序先执行A，执行完A之后在执行B；或者先执行完B再执行A：使用lock关键字

### lock关键字

可以通过lock关键字来控制A和B的执行顺序。使用同一个lock参数的代码，程序会等待前面的代码执行完之后再执行后面的

```C#
using System.Threading;

void start()
{
    static Object o = new object();
    Thread t1 = new Thread(A);
    Thread t2 = new Thread(B);
    t1.start();
    t2.start();
    Thread t3 = new Thread(C);
    t3.start();
}

static void A()
{
    lock(o)
    {
        Debug.Log("我是A函数1");
        Debug.Log("我是A函数2");
    }
}

static void B()
{
    lock(o)
    {
        // Thread.Sleep(1000);   // 暂停1秒
        Debug.Log("我是B函数1");
        Debug.Log("我是B函数2");
    }
}

static void C()
{
    DEbug.Log("我是随机函数");
}
```

此时可能会先执行A，执行完A后再执行B；也有可能先执行B，执行完B之后再执行A。C函数没有被锁住，所以他能出现在任意位置。

补充：这里的o是Object类（基类）。所以，lock的参数可以是任意的类

### 拓展

在unity中将子线程的代码转移到主线程中执行

```C#
using UnityEngine;
using System.Collections.Generic;
using System;

public class MainThreadDispatcher : MonoBehaviour
{
    private static MainThreadDispatcher instance;

    private Queue<Action> actionQueue = new Queue<Action>();		// 初始化一个队列:先进先出的一个数据结构

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Update()
    {
        lock (actionQueue)
        {
            while (actionQueue.Count > 0)
            {
                Action action = actionQueue.Dequeue();		// 取出队列中的一个函数，并执行
                action.Invoke();
            }
        }
    }

    public static void RunOnMainThread(Action action)
    {
        lock (instance.actionQueue)		// 如果有其他的代码（包括自己）使用了lock(instance.actionQueue)，则会等待前面的执行完再执行自己
        {
            instance.actionQueue.Enqueue(action);		// 将传进来的action函数插入到队列中
        }
    }
}
```

在其他函数中可以通过调用`RunOnMainThread()`函数将方法转移到主线程上执行
常用与数据请求上，接收到的数据一般都是在子线程上。但是在unity的子线程中无法访问transform属性等，故需要转移到主线程上执行

```C#
RunOnMainThread(() =>
{
    // 转移到主线程上执行代码
    textValue.text = "你好";
});
```

